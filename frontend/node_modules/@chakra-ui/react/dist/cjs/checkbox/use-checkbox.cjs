'use client';
'use strict';

var useCallbackRef = require('@chakra-ui/hooks/use-callback-ref');
var useMergeRefs = require('@chakra-ui/hooks/use-merge-refs');
var useSafeLayoutEffect = require('@chakra-ui/hooks/use-safe-layout-effect');
var useUpdateEffect = require('@chakra-ui/hooks/use-update-effect');
var attr = require('@chakra-ui/utils/attr');
var callAll = require('@chakra-ui/utils/call-all');
var omit = require('@chakra-ui/utils/omit');
var focusVisible = require('@zag-js/focus-visible');
var react = require('react');
var useFormControl = require('../form-control/use-form-control.cjs');
var visuallyHidden_style = require('../visually-hidden/visually-hidden.style.cjs');

function useCheckbox(props = {}) {
  const formControlProps = useFormControl.useFormControlProps(props);
  const {
    isDisabled,
    isReadOnly,
    isRequired,
    isInvalid,
    id,
    onBlur,
    onFocus,
    "aria-describedby": ariaDescribedBy
  } = formControlProps;
  const {
    defaultChecked,
    isChecked: checkedProp,
    isFocusable,
    onChange,
    isIndeterminate,
    name,
    value,
    tabIndex = void 0,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-invalid": ariaInvalid,
    ...rest
  } = props;
  const htmlProps = omit.omit(rest, [
    "isDisabled",
    "isReadOnly",
    "isRequired",
    "isInvalid",
    "id",
    "onBlur",
    "onFocus",
    "aria-describedby"
  ]);
  const onChangeProp = useCallbackRef.useCallbackRef(onChange);
  const onBlurProp = useCallbackRef.useCallbackRef(onBlur);
  const onFocusProp = useCallbackRef.useCallbackRef(onFocus);
  const [isFocusVisible, setIsFocusVisible] = react.useState(false);
  const [isFocused, setFocused] = react.useState(false);
  const [isHovered, setHovered] = react.useState(false);
  const [isActive, setActive] = react.useState(false);
  react.useEffect(() => {
    return focusVisible.trackFocusVisible(setIsFocusVisible);
  }, []);
  const inputRef = react.useRef(null);
  const [rootIsLabelElement, setRootIsLabelElement] = react.useState(true);
  const [checkedState, setCheckedState] = react.useState(!!defaultChecked);
  const isControlled = checkedProp !== void 0;
  const isChecked = isControlled ? checkedProp : checkedState;
  const handleChange = react.useCallback(
    (event) => {
      if (isReadOnly || isDisabled) {
        event.preventDefault();
        return;
      }
      if (!isControlled) {
        if (isChecked) {
          setCheckedState(event.target.checked);
        } else {
          setCheckedState(isIndeterminate ? true : event.target.checked);
        }
      }
      onChangeProp?.(event);
    },
    [
      isReadOnly,
      isDisabled,
      isChecked,
      isControlled,
      isIndeterminate,
      onChangeProp
    ]
  );
  useSafeLayoutEffect.useSafeLayoutEffect(() => {
    if (inputRef.current) {
      inputRef.current.indeterminate = Boolean(isIndeterminate);
    }
  }, [isIndeterminate]);
  useUpdateEffect.useUpdateEffect(() => {
    if (isDisabled) {
      setFocused(false);
    }
  }, [isDisabled, setFocused]);
  useSafeLayoutEffect.useSafeLayoutEffect(() => {
    const el = inputRef.current;
    if (!el?.form)
      return;
    const formResetListener = () => {
      setCheckedState(!!defaultChecked);
    };
    el.form.addEventListener("reset", formResetListener);
    return () => el.form?.removeEventListener("reset", formResetListener);
  }, []);
  const trulyDisabled = isDisabled && !isFocusable;
  const onKeyDown = react.useCallback(
    (event) => {
      if (event.key === " ") {
        setActive(true);
      }
    },
    [setActive]
  );
  const onKeyUp = react.useCallback(
    (event) => {
      if (event.key === " ") {
        setActive(false);
      }
    },
    [setActive]
  );
  useSafeLayoutEffect.useSafeLayoutEffect(() => {
    if (!inputRef.current)
      return;
    const notInSync = inputRef.current.checked !== isChecked;
    if (notInSync) {
      setCheckedState(inputRef.current.checked);
    }
  }, [inputRef.current]);
  const getCheckboxProps = react.useCallback(
    (props2 = {}, forwardedRef = null) => {
      const onPressDown = (event) => {
        if (isFocused) {
          event.preventDefault();
        }
        setActive(true);
      };
      return {
        ...props2,
        ref: forwardedRef,
        "data-active": attr.dataAttr(isActive),
        "data-hover": attr.dataAttr(isHovered),
        "data-checked": attr.dataAttr(isChecked),
        "data-focus": attr.dataAttr(isFocused),
        "data-focus-visible": attr.dataAttr(isFocused && isFocusVisible),
        "data-indeterminate": attr.dataAttr(isIndeterminate),
        "data-disabled": attr.dataAttr(isDisabled),
        "data-invalid": attr.dataAttr(isInvalid),
        "data-readonly": attr.dataAttr(isReadOnly),
        "aria-hidden": true,
        onMouseDown: callAll.callAllHandlers(props2.onMouseDown, onPressDown),
        onMouseUp: callAll.callAllHandlers(props2.onMouseUp, () => setActive(false)),
        onMouseEnter: callAll.callAllHandlers(
          props2.onMouseEnter,
          () => setHovered(true)
        ),
        onMouseLeave: callAll.callAllHandlers(
          props2.onMouseLeave,
          () => setHovered(false)
        )
      };
    },
    [
      isActive,
      isChecked,
      isDisabled,
      isFocused,
      isFocusVisible,
      isHovered,
      isIndeterminate,
      isInvalid,
      isReadOnly
    ]
  );
  const getIndicatorProps = react.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      "data-active": attr.dataAttr(isActive),
      "data-hover": attr.dataAttr(isHovered),
      "data-checked": attr.dataAttr(isChecked),
      "data-focus": attr.dataAttr(isFocused),
      "data-focus-visible": attr.dataAttr(isFocused && isFocusVisible),
      "data-indeterminate": attr.dataAttr(isIndeterminate),
      "data-disabled": attr.dataAttr(isDisabled),
      "data-invalid": attr.dataAttr(isInvalid),
      "data-readonly": attr.dataAttr(isReadOnly)
    }),
    [
      isActive,
      isChecked,
      isDisabled,
      isFocused,
      isFocusVisible,
      isHovered,
      isIndeterminate,
      isInvalid,
      isReadOnly
    ]
  );
  const getRootProps = react.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...htmlProps,
      ...props2,
      ref: useMergeRefs.mergeRefs(forwardedRef, (node) => {
        if (!node)
          return;
        setRootIsLabelElement(node.tagName === "LABEL");
      }),
      htmlFor: props2.htmlFor !== void 0 ? props2.htmlFor : rootIsLabelElement ? id : void 0,
      onClick: callAll.callAllHandlers(props2.onClick, () => {
        if (!rootIsLabelElement) {
          inputRef.current?.click();
          requestAnimationFrame(() => {
            inputRef.current?.focus({ preventScroll: true });
          });
        }
      }),
      "data-disabled": attr.dataAttr(isDisabled),
      "data-checked": attr.dataAttr(isChecked),
      "data-invalid": attr.dataAttr(isInvalid)
    }),
    [htmlProps, isDisabled, isChecked, isInvalid, rootIsLabelElement, id]
  );
  const getInputProps = react.useCallback(
    (props2 = {}, forwardedRef = null) => {
      return {
        ...props2,
        ref: useMergeRefs.mergeRefs(inputRef, forwardedRef),
        type: "checkbox",
        name,
        value,
        id,
        tabIndex,
        onChange: callAll.callAllHandlers(props2.onChange, handleChange),
        onBlur: callAll.callAllHandlers(
          props2.onBlur,
          onBlurProp,
          () => setFocused(false)
        ),
        onFocus: callAll.callAllHandlers(
          props2.onFocus,
          onFocusProp,
          () => setFocused(true)
        ),
        onKeyDown: callAll.callAllHandlers(props2.onKeyDown, onKeyDown),
        onKeyUp: callAll.callAllHandlers(props2.onKeyUp, onKeyUp),
        required: isRequired,
        checked: isChecked,
        disabled: trulyDisabled,
        readOnly: isReadOnly,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-invalid": ariaInvalid ? Boolean(ariaInvalid) : isInvalid,
        "aria-describedby": ariaDescribedBy,
        "aria-disabled": isDisabled,
        style: visuallyHidden_style.visuallyHiddenStyle
      };
    },
    [
      name,
      value,
      id,
      handleChange,
      onBlurProp,
      onFocusProp,
      onKeyDown,
      onKeyUp,
      isRequired,
      isChecked,
      trulyDisabled,
      isReadOnly,
      ariaLabel,
      ariaLabelledBy,
      ariaInvalid,
      isInvalid,
      ariaDescribedBy,
      isDisabled,
      tabIndex
    ]
  );
  const getLabelProps = react.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      onMouseDown: callAll.callAllHandlers(props2.onMouseDown, stopEvent),
      "data-disabled": attr.dataAttr(isDisabled),
      "data-checked": attr.dataAttr(isChecked),
      "data-invalid": attr.dataAttr(isInvalid)
    }),
    [isChecked, isDisabled, isInvalid]
  );
  const state = {
    isInvalid,
    isFocused,
    isChecked,
    isActive,
    isHovered,
    isIndeterminate,
    isDisabled,
    isReadOnly,
    isRequired
  };
  return {
    state,
    getRootProps,
    getCheckboxProps,
    getIndicatorProps,
    getInputProps,
    getLabelProps,
    htmlProps
  };
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

exports.useCheckbox = useCheckbox;
